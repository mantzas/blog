<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dotnet on Coding Odyssey</title>
    <link>http://blog.mantziaris.eu/categories/dotnet/index.xml</link>
    <description>Recent content in Dotnet on Coding Odyssey</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://blog.mantziaris.eu/categories/dotnet/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Breaking the circuit</title>
      <link>http://blog.mantziaris.eu/blog/2017/01/06/breaking-the-circuit/</link>
      <pubDate>Fri, 06 Jan 2017 13:11:25 +0200</pubDate>
      
      <guid>http://blog.mantziaris.eu/blog/2017/01/06/breaking-the-circuit/</guid>
      <description>

&lt;h1 id=&#34;circuit-breaker-pattern&#34;&gt;Circuit breaker pattern&lt;/h1&gt;

&lt;p&gt;This is probably one of the most useful &amp;ldquo;cloud&amp;rdquo; patterns out there and it is fairly easy to implement.&lt;br /&gt;
There are great articles and implementations, like &lt;a href=&#34;https://github.com/App-vNext/Polly&#34;&gt;Polly&lt;/a&gt;,
already on the internet about this pattern so why another one?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Κρείττον οψιμαθή είναι ή αμαθή.&lt;br /&gt;
Socrates 469-399 BC., Philosopher&lt;/p&gt;

&lt;p&gt;Better too have learned lately than never, as he tried to explain why he learned to play
guitar in his old age.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I have learned better by reading, implementing and writing about something so stick with me.&lt;/p&gt;

&lt;h2 id=&#34;problem&#34;&gt;Problem&lt;/h2&gt;

&lt;p&gt;Almost every application communicate with other services or resources, and they fail&amp;hellip;&lt;/p&gt;

&lt;p&gt;The reasons:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;slow network connections&lt;/li&gt;
&lt;li&gt;timeouts&lt;/li&gt;
&lt;li&gt;the resources being over-committed or temporarily unavailable&lt;/li&gt;
&lt;li&gt;buggy release&lt;/li&gt;
&lt;li&gt;etc&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When this happen our system becomes unstable, unreliable, brittle and failures cascade.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s go with an example of a failing remote service, let&amp;rsquo;s say we have the following scenario&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the remote service times out after 60sec&lt;/li&gt;
&lt;li&gt;our service gets 30 req/s&lt;/li&gt;
&lt;li&gt;the usual response time is 1s&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;each request takes up 1MB of RAM&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;What happens in our application?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The current request takes up resources in order to make the call and blocks (or awaits) for 60sec&lt;/li&gt;
&lt;li&gt;All requests for the same service will suffer the same fate&lt;/li&gt;
&lt;li&gt;Almost 1800 requests will be waiting for response at the end of the first 60s&lt;/li&gt;
&lt;li&gt;Almost 1800MB of RAM is used up at the end of the first 60s&lt;/li&gt;
&lt;li&gt;All clients that call our service fail in the same way&lt;/li&gt;
&lt;li&gt;The failure cascades&lt;/li&gt;
&lt;li&gt;The response times go through the roof and will be 60s for each request due to the timeout&lt;/li&gt;
&lt;li&gt;The SLA, we might have, will be breached&lt;/li&gt;
&lt;li&gt;The perfect storm is about to form&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The above is a simplified example but is not that far fetched.&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;p&gt;Using a circuit breaker can improve the stability and resilience of our application.
The circuit is actually a state machine with 3 states&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Closed, meaning the execution will proceed&lt;/li&gt;
&lt;li&gt;Open, meaning the execution will not proceed and throw a exception or return an error (implementation specific)&lt;/li&gt;
&lt;li&gt;Half-Open, meaning that some executions are allowed after some time in order to check the remote service
and open or close the circuit based on the response&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For deeper knowledge on the pattern please read the following excellent articles&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://msdn.microsoft.com/en-us/library/dn589784.aspx&#34;&gt;MSDN Circuit Breaker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://martinfowler.com/bliki/CircuitBreaker.html&#34;&gt;Martin Fowler Circuit Breaker&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;benefits&#34;&gt;Benefits&lt;/h2&gt;

&lt;p&gt;By using a circuit breaker we have the following benefits:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Fail in a controlled manner&lt;/li&gt;
&lt;li&gt;Fail fast&lt;/li&gt;
&lt;li&gt;Save server resources&lt;/li&gt;
&lt;li&gt;Maintain response times (SLA)&lt;/li&gt;
&lt;li&gt;Handle failures differently when the circuit opens eg

&lt;ul&gt;
&lt;li&gt;Redirect to another resources&lt;/li&gt;
&lt;li&gt;Save for later retry&lt;/li&gt;
&lt;li&gt;etc&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;implementation&#34;&gt;Implementation&lt;/h2&gt;

&lt;p&gt;There are two implementation of the circuit breaker.
They share the same philosophy but are written in C# and Go.
Both implementations have a setting provider interface which can be implemented
in order to get the settings from anywhere. There is a in-memory settings implementation which
holds the settings in memory.
Both implementation are key based which means that for every key
the implementation provides a separate circuit which is actually the state.
The following setting exist for each key:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Failure Threshold at which the circuit opens&lt;/li&gt;
&lt;li&gt;Retry Timeout defines after how much time after the circuit trips will the state be half-open&lt;/li&gt;
&lt;li&gt;Retry Success Threshold defines after how many successful retries will the circuit reset and Closed&lt;/li&gt;
&lt;li&gt;Max Retry Execution Threshold defines how many retries are allowed in the half-open state&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The C# implementation can be found @ &lt;a href=&#34;https://github.com/mantzas/clouddotnet&#34;&gt;clouddotnet&lt;/a&gt;.
The implementation is generic, asynchronous and thread safe.&lt;br /&gt;
The Go implementation can be found @ &lt;a href=&#34;https://github.com/mantzas/gocloud&#34;&gt;gocloud&lt;/a&gt;.
The implementation is idiomatic and &amp;ldquo;goroutine&amp;rdquo; safe.&lt;/p&gt;

&lt;h2 id=&#34;diffs&#34;&gt;Diffs&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Since Go does not have generics the action to be executed returns a interface and a error
so type casting is necessary&lt;/li&gt;
&lt;li&gt;The benchmark for the C# implementation results in 355ns/operation&lt;/li&gt;
&lt;li&gt;The benchmark for the Go implementation results in 562ns/operation&lt;/li&gt;
&lt;li&gt;C# is a lot faster than Go for this implementation which was, to be honest, not expected&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;epilogue&#34;&gt;Epilogue&lt;/h2&gt;

&lt;p&gt;My &lt;a href=&#34;http://github.com/mantzas/blog&#34;&gt;blog&lt;/a&gt; is hosted in github so for any change, improvement or fix
you can either open a issue or submit a pull request.&lt;br /&gt;
The same goes for both implementations.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>To TAP or not to TAP</title>
      <link>http://blog.mantziaris.eu/blog/2016/05/25/to-tap-or-not-to-tap/</link>
      <pubDate>Wed, 25 May 2016 21:35:00 +0300</pubDate>
      
      <guid>http://blog.mantziaris.eu/blog/2016/05/25/to-tap-or-not-to-tap/</guid>
      <description>

&lt;h1 id=&#34;tt-tt&#34;&gt;TT || !TT&lt;/h1&gt;

&lt;p&gt;Ramblings on Tasks, async-await and ASP.NET. The &lt;a href=&#34;https://goo.gl/sO3ZGv&#34;&gt;slides&lt;/a&gt; from the &lt;a href=&#34;http://www.meetup.com/DotNetZone/events/231198572/&#34;&gt;meetup&lt;/a&gt;
 do contain common issues encountered when working with TPL, async-await and ASP.NET along with some good practices. These are off course not all. Please let me know if you have any suggestions. Thanks for attenting.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>