<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Pattern on Coding Odyssey</title>
    <link>http://blog.mantziaris.eu/categories/pattern/index.xml</link>
    <description>Recent content in Pattern on Coding Odyssey</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://blog.mantziaris.eu/categories/pattern/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Tripping the circuit</title>
      <link>http://blog.mantziaris.eu/blog/2017/01/06/tripping-the-circuit/</link>
      <pubDate>Fri, 06 Jan 2017 13:11:25 +0200</pubDate>
      
      <guid>http://blog.mantziaris.eu/blog/2017/01/06/tripping-the-circuit/</guid>
      <description>

&lt;h1 id=&#34;circuit-breaker-pattern&#34;&gt;Circuit breaker pattern&lt;/h1&gt;

&lt;p&gt;This is probably one of the most useful &amp;ldquo;cloud&amp;rdquo; patterns out there and it is fairly easy to implement.&lt;br /&gt;
There are great articles and implementations, like &lt;a href=&#34;https://github.com/App-vNext/Polly&#34;&gt;Polly&lt;/a&gt;,
already on the internet about this pattern so why another one?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Κρείττον οψιμαθή είναι ή αμαθή.&lt;br /&gt;
Socrates 469-399 BC., Philosopher&lt;/p&gt;

&lt;p&gt;Better too have learned lately than never, as he tried to explain why he learned to play
guitar in his old age.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I have learned better by reading, implementing and writing about something so stick with me.&lt;/p&gt;

&lt;h2 id=&#34;problem&#34;&gt;Problem&lt;/h2&gt;

&lt;p&gt;Almost every application communicate with other services or resources, and they fail&amp;hellip;&lt;/p&gt;

&lt;p&gt;The reasons:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;slow network connections&lt;/li&gt;
&lt;li&gt;timeouts&lt;/li&gt;
&lt;li&gt;the resources being over-committed or temporarily unavailable&lt;/li&gt;
&lt;li&gt;buggy release&lt;/li&gt;
&lt;li&gt;etc&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When this happen our system becomes unstable, unreliable, brittle and failures cascade.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s go with an example of a failing remote service, let&amp;rsquo;s say we have the following scenario&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the remote service times out after 60sec&lt;/li&gt;
&lt;li&gt;our service gets 30 req/s&lt;/li&gt;
&lt;li&gt;the usual response time is 1s&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;each request takes up 1MB of RAM&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;What happens in our application?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The current request takes up resources in order to make the call and blocks (or awaits) for 60sec&lt;/li&gt;
&lt;li&gt;All requests for the same service will suffer the same fate&lt;/li&gt;
&lt;li&gt;Almost 1800 requests will be waiting for response at the end of the first 60s&lt;/li&gt;
&lt;li&gt;Almost 1800MB of RAM is used up at the end of the first 60s&lt;/li&gt;
&lt;li&gt;All clients that call our service fail in the same way&lt;/li&gt;
&lt;li&gt;The failure cascades&lt;/li&gt;
&lt;li&gt;The response times go through the roof and will be 60s for each request due to the timeout&lt;/li&gt;
&lt;li&gt;The SLA, we might have, will be breached&lt;/li&gt;
&lt;li&gt;The perfect storm is about to form&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The above is a simplified example but is not that far fetched.&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;p&gt;Using a circuit breaker can improve the stability and resilience of our application.
The circuit is actually a state machine with 3 states&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Closed, meaning the execution will proceed&lt;/li&gt;
&lt;li&gt;Open, meaning the execution will not proceed and throw a exception or return an error (implementation specific)&lt;/li&gt;
&lt;li&gt;Half-Open, meaning that some executions are allowed after some time in order to check the remote service
and open or close the circuit based on the response&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For deeper knowledge on the pattern please read the following excellent articles&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://msdn.microsoft.com/en-us/library/dn589784.aspx&#34;&gt;MSDN Circuit Breaker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://martinfowler.com/bliki/CircuitBreaker.html&#34;&gt;Martin Fowler Circuit Breaker&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;benefits&#34;&gt;Benefits&lt;/h2&gt;

&lt;p&gt;By using a circuit breaker we have the following benefits:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Fail in a controlled manner&lt;/li&gt;
&lt;li&gt;Fail fast&lt;/li&gt;
&lt;li&gt;Save server resources&lt;/li&gt;
&lt;li&gt;Maintain response times (SLA)&lt;/li&gt;
&lt;li&gt;Handle failures differently when the circuit opens eg

&lt;ul&gt;
&lt;li&gt;Redirect to another resources&lt;/li&gt;
&lt;li&gt;Save for later retry&lt;/li&gt;
&lt;li&gt;etc&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;implementation&#34;&gt;Implementation&lt;/h2&gt;

&lt;p&gt;There are two implementation of the circuit breaker.
They share the same philosophy but are written in C# and Go.
Both implementations have a setting provider interface which can be implemented
in order to get the settings from anywhere. There is a in-memory settings implementation which
holds the settings in memory.
Both implementation are key based which means that for every key
the implementation provides a separate circuit which is actually the state.
The following setting exist for each key:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Failure Threshold at which the circuit opens&lt;/li&gt;
&lt;li&gt;Retry Timeout defines after how much time after the circuit trips will the state be half-open&lt;/li&gt;
&lt;li&gt;Retry Success Threshold defines after how many successful retries will the circuit reset and Closed&lt;/li&gt;
&lt;li&gt;Max Retry Execution Threshold defines how many retries are allowed in the half-open state&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The C# implementation can be found @ &lt;a href=&#34;https://github.com/mantzas/clouddotnet&#34;&gt;clouddotnet&lt;/a&gt;.
The implementation is generic, asynchronous and thread safe.&lt;br /&gt;
The Go implementation can be found @ &lt;a href=&#34;https://github.com/mantzas/gocloud&#34;&gt;gocloud&lt;/a&gt;.
The implementation is idiomatic and &amp;ldquo;goroutine&amp;rdquo; safe.&lt;/p&gt;

&lt;h2 id=&#34;diffs&#34;&gt;Diffs&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Since Go does not have generics the action to be executed returns a interface and a error
so type casting is necessary&lt;/li&gt;
&lt;li&gt;The benchmark for the C# implementation results in 355ns/operation&lt;/li&gt;
&lt;li&gt;The benchmark for the Go implementation results in 562ns/operation&lt;/li&gt;
&lt;li&gt;C# is a lot faster than Go for this implementation which was, to be honest, not expected&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;epilogue&#34;&gt;Epilogue&lt;/h2&gt;

&lt;p&gt;My &lt;a href=&#34;http://github.com/mantzas/blog&#34;&gt;blog&lt;/a&gt; is hosted in github so for any change, improvement or fix
you can either open a issue or submit a pull request.&lt;br /&gt;
The same goes for both implementations.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The Repository and Unit of Work pattern</title>
      <link>http://blog.mantziaris.eu/blog/2016/10/24/the-repository-and-unit-of-work-pattern/</link>
      <pubDate>Mon, 24 Oct 2016 22:30:54 +0300</pubDate>
      
      <guid>http://blog.mantziaris.eu/blog/2016/10/24/the-repository-and-unit-of-work-pattern/</guid>
      <description>

&lt;p&gt;Yes, i know not this again. Is this not the one millionth time that someone blogs about that?
Yes, yes and yes but…
It is always good to repeat things and we all know that&lt;/p&gt;

&lt;p&gt;“Repetition is the mother of learning, the father of action, which makes it the architect of accomplishment.” ― &lt;a href=&#34;https://en.wikipedia.org/wiki/Zig_Ziglar&#34;&gt;Zig Ziglar&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;There are still implementations out there that might benefit from this…&lt;/p&gt;

&lt;p&gt;So let’s start with some definitions.&lt;/p&gt;

&lt;h2 id=&#34;repository&#34;&gt;Repository&lt;/h2&gt;

&lt;p&gt;Quoting &lt;a href=&#34;http://martinfowler.com/eaaCatalog/repository.html&#34;&gt;Martin Fowler’s Definition&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;A system with a complex domain model often benefits from a layer, such as the one provided by Data Mapper (165),
that isolates domain objects from details of the database access code. In such systems it can be worthwhile to build another layer of abstraction
over the mapping layer where query construction code is concentrated. This becomes more important when there are a large number of domain classes or heavy querying.
In these cases particularly, adding this layer helps minimize duplicate query logic. A Repository mediates between the domain and data mapping layers,
acting like an in-memory domain object collection. Client objects construct query specifications declaratively and submit them to Repository for satisfaction.
Objects can be added to and removed from the Repository, as they can from a simple collection of objects, and the mapping code encapsulated by the Repository
will carry out the appropriate operations behind the scenes. Conceptually, a Repository encapsulates the set of objects persisted in a data store and the operations
performed over them, providing a more object-oriented view of the persistence layer. Repository also supports the objective of achieving a clean separation and
one-way dependency between the domain and data mapping layers.&lt;/p&gt;

&lt;p&gt;Reading different sources (&lt;a href=&#34;https://msdn.microsoft.com/en-us/library/ff649690.aspx&#34;&gt;MSDN The Repository Pattern&lt;/a&gt;,
&lt;a href=&#34;http://martinfowler.com/eaaCatalog/repository.html&#34;&gt;Martin Fowler: Repository&lt;/a&gt; etc) about the repository pattern the following properties emerge:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It maps between Domain Objects and Data objects&lt;/li&gt;
&lt;li&gt;It does not expose the data layer to the outside world&lt;/li&gt;
&lt;li&gt;It consolidates all data access patterns in one place thus help with code deduplication&lt;/li&gt;
&lt;li&gt;It has a single responsibility&lt;/li&gt;
&lt;li&gt;It is simple to implement&lt;/li&gt;
&lt;li&gt;It has a one way dependency between the domain and the data layer&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A simple example is the following application repository(C#):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface IApplicationRepository
{
    Task DeleteAsync(int id);
    Task&amp;lt;ApplicationModel&amp;gt; GetAsync(int id);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By providing an interface we can leave the implementation up top the developer to choose the data access library they wish.
The argument and return values of this interface should be domain specific objects and not the data objects to avoid spilling the data
into other layers and have a clean separation.&lt;/p&gt;

&lt;p&gt;By using the above i had the chance to change the underlying implementation with anything i wished to experimented with.
First everything was EF, then Simple.Data then Dapper etc. You could even mix and match any of the above since every implementation
in the end will use a SqlConnection. It is really easy to change the underlying implementation.&lt;/p&gt;

&lt;p&gt;You may think that changing the implementation happens not that often (migrate from EF to Dapper or from nHibernate to EF or Dapper etc)
but it can happen and is a really cheap abstraction over your data layer implementation. It further promotes clean separation which is always something worth doing.
This allows the application to not depend directly on the data access library and allows for future change with little cost.
For example if you have a application that uses nHibernate, which was maybe a good choice in the past, you are missing out some things
that other ORM provide like async calls or even the new .Net Core which may or may not happen for nHibernate. Dapper and EF already have the above.&lt;/p&gt;

&lt;p&gt;The implementation of the interface does need something in order to work with the data layer. This can be a SqlConnection, DbContext (EF), Session (NHibernate) etc.
This will be injected to each repository and will generally be implemented in the Unit of Work.&lt;/p&gt;

&lt;h2 id=&#34;unit-of-work&#34;&gt;Unit of Work&lt;/h2&gt;

&lt;p&gt;Quoting &lt;a href=&#34;http://martinfowler.com/eaaCatalog/unitOfWork.html&#34;&gt;Martin Fowler&amp;rsquo;s Definition&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;A Unit of Work keeps track of everything you do during a business transaction that can affect the database.
When you&amp;rsquo;re done, it figures out everything that needs to be done to alter the database as a result of your work.&lt;/p&gt;

&lt;p&gt;So the UoW (Unit of Work) is responsible for keeping the db object (SqlConnection, DbContext) and handling the final commit in order to persist everything to DB.&lt;/p&gt;

&lt;p&gt;A simple interface (C#) that has to be implemented is the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface IUnitOfWork : IDisposable
{
    IApplicationRepository Applications { get; }
    Task CommitAsync();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is just a wrapper around our db object (SqlConnection, DbContext etc) and the implementation of the commit.
When we have a UoW we have at our hands all the necessary repositories, so interacting with them is really easy.&lt;/p&gt;

&lt;h2 id=&#34;ef-baked-implementation-and-usage&#34;&gt;EF baked implementation and usage&lt;/h2&gt;

&lt;p&gt;Now we have the the following implementation for the application repository&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class ApplicationRepository : IDataAccess&amp;lt;ApplicationDbModel&amp;gt;, 
                                     IApplicationRepository
{
    public ApplicationRepository(DbContext dbContext, IMapper mapper) : 
        base(dbContext, mapper)
    {
    }

    public Task DeleteAsync(int id) =&amp;gt; base.DeleteAsync(id);

    public async Task&amp;lt;ApplicationModel&amp;gt; GetAsync(int id)
    {
            var application = await GetAll()
                        .Where(p =&amp;gt; p.Id == id)
                        .SingleOrDefaultAsync();
            return mapper&amp;lt;ApplicationModel&amp;gt;(application);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Where the base repository is a EF implementation of the following interface:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface IDataAccess&amp;lt;T&amp;gt; where T : class
{
    IQueryable&amp;lt;T&amp;gt; GetAll();
    Task&amp;lt;T&amp;gt; GetByIdAsync(params object[] keyValues);
    void Add(T entity);
    void Update(T entity);
    void Delete(T entity);
    Task DeleteAsync(params object[] keyValues);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is fairly easy to implementing another data access library. A dapper implementation of the application repository has
as constructor parameter a SqlConnection and the actual implementation of the interface methods. That’s it.&lt;/p&gt;

&lt;p&gt;The unit of work implementation is the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public sealed class UnitOfWork : IUnitOfWork
{
    private readonly IMapper _mapper;
    private DbContext _dbContext;

    public UnitOfWork(DbContext dbContext, IMapper mapper)
    {
        _dbContext= dbContext;
        _mapper = mapper;
    }

    public Task&amp;lt;int&amp;gt; CommitAsync()
    {
        return _dbContext.SaveChangesAsync();
    }

    public IApplicationRepository Applications =&amp;gt; 
        new ApplicationRepository(_dbContext, _mapper);

    //Implement IDisposable
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a simple implementation of the UoW. Do not mind that some features are missing like transaction handling
(DbContext.Database.BeginTransaction() and then commit or rollback) a repository factory etc which are fairly easy to implement.&lt;/p&gt;

&lt;p&gt;And how is this used?&lt;/p&gt;

&lt;p&gt;Let’s assume we have a Unit Of Work Factory implemented so the code would be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using (var uow = _unitOfWorkFactory.Create())
{
    var application = await uow.Applications.GetAsync(1, 1);
    await uow.Applications.DeleteAsync(application.Id);
    await uow.CommitAsync();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Easy and clean, isn’t it? Everything is in one place, at the end it get’s committed and properly disposed.
Since EF exposes the connection through the DbContext we can actually use Dapper also and have a mixed data access layer repository
in order to handle some hotspots where EF does not play well.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;The repository and the unit of work patterns are fairly easy to implement. They provide a proper data access abstraction and expose only the needed domain object
and do not spill the data object into the upper layers. The only thing needed in order to use this is to inject the unit of work factory and we have our db in our hand.
Hope this is helpful. Any comment, discussion or fix is highly welcome.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>